# Conteúdo completo do patrimonio_controller.py
from PySide6.QtWidgets import QWidget, QMessageBox, QTableWidget, QTableWidgetItem, QDialog, QVBoxLayout, QFormLayout, QLineEdit, QDateEdit, QDoubleSpinBox, QComboBox, QPushButton
from PySide6.QtCore import QDate, QDateTime
import datetime
from database_manager import DatabaseManager
import math

class PatrimonioController(QWidget):
    def __init__(self, ui_widget: QWidget, db_manager: DatabaseManager):
        super().__init__()
        self.ui = ui_widget
        self.db_manager = db_manager
        self.setup_ui_connections()
        self.load_patrimonios()
        self.populate_comboboxes()

    def setup_ui_connections(self):
        self.ui.findChild(QPushButton, "btn_novo").clicked.connect(self.abrir_cadastro_patrimonio)
        self.ui.findChild(QPushButton, "btn_editar").clicked.connect(self.editar_patrimonio)
        self.ui.findChild(QPushButton, "btn_excluir").clicked.connect(self.excluir_patrimonio) # Baixa de patrimônio
        self.ui.findChild(QPushButton, "btn_filtrar").clicked.connect(self.load_patrimonios)
        self.ui.findChild(QPushButton, "btn_limpar").clicked.connect(self.limpar_filtros)

    def populate_comboboxes(self):
        cb_categoria = self.ui.findChild(QComboBox, "cb_categoria")
        cb_setor = self.ui.findChild(QComboBox, "cb_setor")
        cb_status = self.ui.findChild(QComboBox, "cb_status")

        if cb_categoria:
            cb_categoria.clear()
            cb_categoria.addItem("Categoria") # Placeholder
            categorias = self.db_manager.fetch_all("SELECT nome_categoria FROM categorias")
            for cat in categorias: cb_categoria.addItem(cat[0])
        
        if cb_setor:
            cb_setor.clear()
            cb_setor.addItem("Setor") # Placeholder
            setores = self.db_manager.fetch_all("SELECT nome_setor_local FROM setores_locais")
            for setor in setores: cb_setor.addItem(setor[0])

        if cb_status:
            cb_status.clear()
            cb_status.addItem("Status") # Placeholder
            cb_status.addItems(["ativo", "baixado", "em_manutencao", "desaparecido"])

    def load_patrimonios(self):
        # Lógica para atualizar o valor_atual no banco de dados antes de exibir
        self.atualizar_valores_depreciados()
        
        table = self.ui.findChild(QTableWidget, "tbl_patrimonio")
        if not table: return

        table.setRowCount(0)
        
        query = """
            SELECT 
                p.id_patrimonio, p.nome, p.descricao, p.numero_serie, p.data_aquisicao, p.valor_compra, 
                c.nome_categoria, f.nome_fornecedor, sl.nome_setor_local, p.status
            FROM 
                patrimonios p
            LEFT JOIN 
                categorias c ON p.id_categoria = c.id_categoria
            LEFT JOIN 
                fornecedores f ON p.id_fornecedor = f.id_fornecedor
            LEFT JOIN 
                setores_locais sl ON p.id_setor_local = sl.id_setor_local
            WHERE 1=1
        """
        params = []

        busca = self.ui.findChild(QLineEdit, "le_busca").text()
        if busca:
            query += " AND (p.nome LIKE %s OR p.descricao LIKE %s OR p.numero_serie LIKE %s)"
            params.extend([f"%{busca}%", f"%{busca}%", f"%{busca}%"])

        categoria = self.ui.findChild(QComboBox, "cb_categoria").currentText()
        if categoria and categoria != "Categoria":
            query += " AND c.nome_categoria = %s"
            params.append(categoria)

        setor = self.ui.findChild(QComboBox, "cb_setor").currentText()
        if setor and setor != "Setor":
            query += " AND sl.nome_setor_local = %s"
            params.append(setor)

        status = self.ui.findChild(QComboBox, "cb_status").currentText()
        if status and status != "Status":
            query += " AND p.status = %s"
            params.append(status)

        patrimonios = self.db_manager.fetch_all(query, tuple(params))
        
        if patrimonios:
            table.setRowCount(len(patrimonios))
            # Definir cabeçalhos da tabela, incluindo a nova coluna de Valor Atual
            headers = ["ID", "Nome", "Descrição", "Número de Série", "Data Aquisição", "Valor Compra", "Valor Atual", "Categoria", "Fornecedor", "Setor/Local", "Status"]
            table.setColumnCount(len(headers))
            table.setHorizontalHeaderLabels(headers)

            for row_idx, patrimonio in enumerate(patrimonios):
                
                # Adicionar o Valor Atual (que será calculado e atualizado no banco de dados)
                # O valor atual será o valor_compra (índice 5)
                valor_compra = float(patrimonio[5])
                # Busca o valor atualizado no banco de dados
                valor_atual = self.db_manager.fetch_one("SELECT valor_atual FROM patrimonios WHERE id_patrimonio = %s", (patrimonio[0],))[0]
                
                # Ajustar os índices para a nova coluna 'Valor Atual'
                table.setItem(row_idx, 0, QTableWidgetItem(str(patrimonio[0]))) # ID
                table.setItem(row_idx, 1, QTableWidgetItem(str(patrimonio[1]))) # Nome
                table.setItem(row_idx, 2, QTableWidgetItem(str(patrimonio[2]))) # Descrição
                table.setItem(row_idx, 3, QTableWidgetItem(str(patrimonio[3]))) # Número de Série
                table.setItem(row_idx, 4, QTableWidgetItem(str(patrimonio[4]))) # Data Aquisição
                table.setItem(row_idx, 5, QTableWidgetItem(f"R$ {valor_compra:.2f}")) # Valor Compra
                table.setItem(row_idx, 6, QTableWidgetItem(f"R$ {valor_atual:.2f}")) # Valor Atual (NOVO)
                table.setItem(row_idx, 7, QTableWidgetItem(str(patrimonio[6]))) # Categoria
                table.setItem(row_idx, 8, QTableWidgetItem(str(patrimonio[7]))) # Fornecedor
                table.setItem(row_idx, 9, QTableWidgetItem(str(patrimonio[8]))) # Setor/Local
                table.setItem(row_idx, 10, QTableWidgetItem(str(patrimonio[9]))) # Status

        table.resizeColumnsToContents()

    def limpar_filtros(self):
        self.ui.findChild(QLineEdit, "le_busca").clear()
        self.ui.findChild(QComboBox, "cb_categoria").setCurrentIndex(0)
        self.ui.findChild(QComboBox, "cb_setor").setCurrentIndex(0)
        self.ui.findChild(QComboBox, "cb_status").setCurrentIndex(0)
        self.load_patrimonios()

    def abrir_cadastro_patrimonio(self):
        dialog = QDialog(self.ui)
        dialog.setWindowTitle("Cadastrar Novo Patrimônio")
        layout = QVBoxLayout()
        form_layout = QFormLayout()

        self.nome_input = QLineEdit()
        self.descricao_input = QLineEdit()
        self.numero_serie_input = QLineEdit()
        self.data_aquisicao_input = QDateEdit(QDate.currentDate())
        self.data_aquisicao_input.setCalendarPopup(True)
        self.valor_compra_input = QDoubleSpinBox()
        self.valor_compra_input.setPrefix("R$ ")
        self.valor_compra_input.setMaximum(99999999.99)
        self.estado_conservacao_input = QComboBox()
        self.estado_conservacao_input.addItems(["novo", "bom", "regular", "ruim"])
        self.categoria_combo = QComboBox()
        self.fornecedor_combo = QComboBox()
        self.setor_local_combo = QComboBox()
        self.status_combo = QComboBox()
        self.status_combo.addItems(["ativo", "baixado", "em_manutencao", "desaparecido"])

        # Popula os ComboBoxes de FKs
        self.categoria_combo.addItem("Selecione uma Categoria")
        categorias = self.db_manager.fetch_all("SELECT id_categoria, nome_categoria FROM categorias")
        for cat_id, cat_nome in categorias: self.categoria_combo.addItem(cat_nome, cat_id)

        self.fornecedor_combo.addItem("Selecione um Fornecedor")
        fornecedores = self.db_manager.fetch_all("SELECT id_fornecedor, nome_fornecedor FROM fornecedores")
        for forn_id, forn_nome in fornecedores: self.fornecedor_combo.addItem(forn_nome, forn_id)

        self.setor_local_combo.addItem("Selecione um Setor/Local")
        setores_locais = self.db_manager.fetch_all("SELECT id_setor_local, nome_setor_local FROM setores_locais")
        for sl_id, sl_nome in setores_locais: self.setor_local_combo.addItem(sl_nome, sl_id)

        form_layout.addRow("Nome:", self.nome_input)
        form_layout.addRow("Descrição:", self.descricao_input)
        form_layout.addRow("Número de Série:", self.numero_serie_input)
        form_layout.addRow("Data de Aquisição:", self.data_aquisicao_input)
        form_layout.addRow("Valor de Compra:", self.valor_compra_input)
        form_layout.addRow("Estado de Conservação:", self.estado_conservacao_input)
        form_layout.addRow("Categoria:", self.categoria_combo)
        form_layout.addRow("Fornecedor:", self.fornecedor_combo)
        form_layout.addRow("Setor/Local:", self.setor_local_combo)
        form_layout.addRow("Status:", self.status_combo)

        btn_salvar = QPushButton("Salvar")
        btn_salvar.clicked.connect(lambda: self.salvar_patrimonio(dialog))

        layout.addLayout(form_layout)
        layout.addWidget(btn_salvar)
        dialog.setLayout(layout)
        dialog.exec()

    def salvar_patrimonio(self, dialog):
        nome = self.nome_input.text()
        descricao = self.descricao_input.text()
        numero_serie = self.numero_serie_input.text()
        data_aquisicao = self.data_aquisicao_input.date().toString("yyyy-MM-dd")
        valor_compra = self.valor_compra_input.value()
        estado_conservacao = self.estado_conservacao_input.currentText()
        id_categoria = self.categoria_combo.currentData()
        id_fornecedor = self.fornecedor_combo.currentData()
        id_setor_local = self.setor_local_combo.currentData()
        status = self.status_combo.currentText()

        if not all([nome, descricao, numero_serie, data_aquisicao, valor_compra is not None, estado_conservacao, id_categoria, id_setor_local, status]):
            QMessageBox.warning(dialog, "Erro", "Todos os campos obrigatórios devem ser preenchidos.")
            return
        
        # Fornecedor pode ser opcional, então verificamos se foi selecionado
        if id_fornecedor == "Selecione um Fornecedor":
            id_fornecedor = None

        # O valor atual é igual ao valor de compra no momento do cadastro
        valor_atual = valor_compra

        query = "INSERT INTO patrimonios (nome, descricao, numero_serie, data_aquisicao, valor_compra, valor_atual, estado_conservacao, id_categoria, id_fornecedor, id_setor_local, status) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"
        params = (nome, descricao, numero_serie, data_aquisicao, valor_compra, valor_atual, estado_conservacao, id_categoria, id_fornecedor, id_setor_local, status)

        if self.db_manager.execute_query(query, params):
            QMessageBox.information(dialog, "Sucesso", "Patrimônio cadastrado com sucesso!")
            dialog.accept()
            self.load_patrimonios()
        else:
            QMessageBox.critical(dialog, "Erro", "Falha ao cadastrar patrimônio. Verifique o número de série, ele deve ser único.")

    def editar_patrimonio(self):
        table = self.ui.findChild(QTableWidget, "tbl_patrimonio")
        selected_rows = table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self.ui, "Edição", "Selecione um patrimônio para editar.")
            return
        
        row = selected_rows[0].row()
        id_patrimonio_original = int(table.item(row, 0).text()) # ID é a primeira coluna

        dialog = QDialog(self.ui)
        dialog.setWindowTitle("Editar Patrimônio")
        layout = QVBoxLayout()
        form_layout = QFormLayout()

        # Carregar dados existentes
        patrimonio_data = self.db_manager.fetch_one("SELECT nome, descricao, numero_serie, data_aquisicao, valor_compra, estado_conservacao, id_categoria, id_fornecedor, id_setor_local, status FROM patrimonios WHERE id_patrimonio = %s", (id_patrimonio_original,))
        if not patrimonio_data:
            QMessageBox.critical(self.ui, "Erro", "Patrimônio não encontrado para edição.")
            return

        self.nome_input = QLineEdit(patrimonio_data[0])
        self.descricao_input = QLineEdit(patrimonio_data[1])
        self.numero_serie_input = QLineEdit(patrimonio_data[2])
        self.data_aquisicao_input = QDateEdit(QDate.fromString(str(patrimonio_data[3]), "yyyy-MM-dd"))
        self.data_aquisicao_input.setCalendarPopup(True)
        self.valor_compra_input = QDoubleSpinBox()
        self.valor_compra_input.setPrefix("R$ ")
        self.valor_compra_input.setMaximum(99999999.99)
        self.valor_compra_input.setValue(float(patrimonio_data[4]))
        self.estado_conservacao_input = QComboBox()
        self.estado_conservacao_input.addItems(["novo", "bom", "regular", "ruim"])
        self.estado_conservacao_input.setCurrentText(patrimonio_data[5])
        self.categoria_combo = QComboBox()
        self.fornecedor_combo = QComboBox()
        self.setor_local_combo = QComboBox()
        self.status_combo = QComboBox()
        self.status_combo.addItems(["ativo", "baixado", "em_manutencao", "desaparecido"])
        self.status_combo.setCurrentText(patrimonio_data[9])

        # Popula e seleciona os ComboBoxes de FKs
        self.categoria_combo.addItem("Selecione uma Categoria")
        categorias = self.db_manager.fetch_all("SELECT id_categoria, nome_categoria FROM categorias")
        for cat_id, cat_nome in categorias:
            self.categoria_combo.addItem(cat_nome, cat_id)
            if cat_id == patrimonio_data[6]: self.categoria_combo.setCurrentText(cat_nome)

        self.fornecedor_combo.addItem("Selecione um Fornecedor")
        fornecedores = self.db_manager.fetch_all("SELECT id_fornecedor, nome_fornecedor FROM fornecedores")
        for forn_id, forn_nome in fornecedores:
            self.fornecedor_combo.addItem(forn_nome, forn_id)
            if forn_id == patrimonio_data[7]: self.fornecedor_combo.setCurrentText(forn_nome)

        self.setor_local_combo.addItem("Selecione um Setor/Local")
        setores_locais = self.db_manager.fetch_all("SELECT id_setor_local, nome_setor_local FROM setores_locais")
        for sl_id, sl_nome in setores_locais:
            self.setor_local_combo.addItem(sl_nome, sl_id)
            if sl_id == patrimonio_data[8]: self.setor_local_combo.setCurrentText(sl_nome)

        form_layout.addRow("Nome:", self.nome_input)
        form_layout.addRow("Descrição:", self.descricao_input)
        form_layout.addRow("Número de Série:", self.numero_serie_input)
        form_layout.addRow("Data de Aquisição:", self.data_aquisicao_input)
        form_layout.addRow("Valor de Compra:", self.valor_compra_input)
        form_layout.addRow("Estado de Conservação:", self.estado_conservacao_input)
        form_layout.addRow("Categoria:", self.categoria_combo)
        form_layout.addRow("Fornecedor:", self.fornecedor_combo)
        form_layout.addRow("Setor/Local:", self.setor_local_combo)
        form_layout.addRow("Status:", self.status_combo)

        btn_salvar = QPushButton("Salvar Alterações")
        btn_salvar.clicked.connect(lambda: self.atualizar_patrimonio(dialog, id_patrimonio_original))

        layout.addLayout(form_layout)
        layout.addWidget(btn_salvar)
        dialog.setLayout(layout)
        dialog.exec()

    def atualizar_patrimonio(self, dialog, id_patrimonio_original):
        nome = self.nome_input.text()
        descricao = self.descricao_input.text()
        numero_serie = self.numero_serie_input.text()
        data_aquisicao = self.data_aquisicao_input.date().toString("yyyy-MM-dd")
        valor_compra = self.valor_compra_input.value()
        estado_conservacao = self.estado_conservacao_input.currentText()
        id_categoria = self.categoria_combo.currentData()
        id_fornecedor = self.fornecedor_combo.currentData()
        id_setor_local = self.setor_local_combo.currentData()
        status = self.status_combo.currentText()

        if not all([nome, descricao, numero_serie, data_aquisicao, valor_compra is not None, estado_conservacao, id_categoria, id_setor_local, status]):
            QMessageBox.warning(dialog, "Erro", "Todos os campos obrigatórios devem ser preenchidos.")
            return
        
        # Fornecedor pode ser opcional, então verificamos se foi selecionado
        if id_fornecedor == "Selecione um Fornecedor":
            id_fornecedor = None

        query = "UPDATE patrimonios SET nome=%s, descricao=%s, numero_serie=%s, data_aquisicao=%s, valor_compra=%s, estado_conservacao=%s, id_categoria=%s, id_fornecedor=%s, id_setor_local=%s, status=%s WHERE id_patrimonio=%s"
        params = (nome, descricao, numero_serie, data_aquisicao, valor_compra, estado_conservacao, id_categoria, id_fornecedor, id_setor_local, status, id_patrimonio_original)

        if self.db_manager.execute_query(query, params):
            QMessageBox.information(dialog, "Sucesso", "Patrimônio atualizado com sucesso!")
            dialog.accept()
            self.load_patrimonios()
        else:
            QMessageBox.critical(dialog, "Erro", "Falha ao atualizar patrimônio. Verifique o número de série, ele deve ser único.")

    def registrar_movimentacao(self, id_patrimonio, tipo, origem, destino, observacoes=""):
        # Assumindo que o usuário logado é o ID 1 para fins de teste
        id_usuario = 1 
        
        query = """
        INSERT INTO movimentacoes (id_patrimonio, id_usuario, tipo_movimentacao, origem, destino, observacoes)
        VALUES (%s, %s, %s, %s, %s, %s)
        """
        params = (id_patrimonio, id_usuario, tipo, origem, destino, observacoes)
        
        return self.db_manager.execute_query(query, params)

    def excluir_patrimonio(self):
        table = self.ui.findChild(QTableWidget, "tbl_patrimonio")
        selected_rows = table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self.ui, "Excluir", "Selecione um patrimônio para excluir (baixar).")
            return

        row = selected_rows[0].row()
        id_patrimonio = int(table.item(row, 0).text())
        nome_patrimonio = table.item(row, 1).text()
        local_atual = table.item(row, 9).text() # Setor/Local

        reply = QMessageBox.question(self.ui, "Confirmação", 
                                     f"Deseja realmente baixar o patrimônio \'{nome_patrimonio}\' (ID: {id_patrimonio})? Isso irá alterar seu status para 'baixado' e registrar uma movimentação.",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        
        if reply == QMessageBox.Yes:
            # 1. Atualizar o status do patrimônio para 'baixado'
            query = "UPDATE patrimonios SET status = %s, data_baixa = %s WHERE id_patrimonio = %s"
            params = ("baixado", QDate.currentDate().toString("yyyy-MM-dd"), id_patrimonio)
            
            if self.db_manager.execute_query(query, params):
                # 2. Registrar a movimentação de baixa
                if self.registrar_movimentacao(id_patrimonio, 'baixa', local_atual, 'Baixado', f"Baixa do patrimônio {nome_patrimonio}"):
                    QMessageBox.information(self.ui, "Sucesso", "Patrimônio baixado e movimentação registrada com sucesso!")
                    self.load_patrimonios()
                else:
                    QMessageBox.critical(self.ui, "Erro", "Patrimônio baixado, mas falha ao registrar a movimentação.")
            else:
                QMessageBox.critical(self.ui, "Erro", "Falha ao baixar patrimônio.")

    def calcular_depreciacao(self, data_aquisicao_str, valor_compra):
        try:
            data_aquisicao = datetime.datetime.strptime(data_aquisicao_str, "%Y-%m-%d").date()
            hoje = datetime.date.today()
            
            # Constantes para Depreciação Linear (5 anos de vida útil)
            VIDA_UTIL_ANOS = 5
            TAXA_DEPRECIACAO_ANUAL = 1 / VIDA_UTIL_ANOS # 20% ao ano

            diferenca_dias = (hoje - data_aquisicao).days
            anos_passados = diferenca_dias / 365.25
            
            # Depreciação acumulada (Valor de Compra * Taxa Anual * Anos Passados)
            depreciacao_acumulada = valor_compra * TAXA_DEPRECIACAO_ANUAL * anos_passados
            
            # Limita a depreciação ao valor de compra (o valor atual nunca será negativo)
            depreciacao_acumulada = min(depreciacao_acumulada, valor_compra)
            
            valor_atual = valor_compra - depreciacao_acumulada
            
            return max(0.0, valor_atual)
        except Exception as e:
            # print(f"Erro ao calcular depreciação: {e}")
            return valor_compra # Retorna o valor original em caso de erro

    def atualizar_valores_depreciados(self):
        """Atualiza o campo valor_atual de todos os patrimônios ativos no banco de dados."""
        # Note: Este método assume que a tabela patrimonios tem a coluna valor_atual
        patrimonios_ativos = self.db_manager.fetch_all("SELECT id_patrimonio, valor_compra, data_aquisicao FROM patrimonios WHERE status = 'ativo'")
        
        for id_patrimonio, valor_compra, data_aquisicao in patrimonios_ativos:
            valor_atual = self.calcular_depreciacao(str(data_aquisicao), float(valor_compra))
            
            query = "UPDATE patrimonios SET valor_atual = %s WHERE id_patrimonio = %s"
            self.db_manager.execute_query(query, (valor_atual, id_patrimonio))

    def refresh(self):
        self.populate_comboboxes() # Recarrega os comboboxes de filtro caso dados de categorias/setores mudem
        self.load_patrimonios()

# CÓDIGO FINAL PARA patrimonio_controller.py (Já inclui Movimentação e Depreciação)
from PySide6.QtWidgets import QWidget, QMessageBox, QTableWidget, QTableWidgetItem, QDialog, QVBoxLayout, QFormLayout, QLineEdit, QDateEdit, QDoubleSpinBox, QComboBox, QPushButton
from PySide6.QtCore import QDate, QDateTime
import datetime
from database_manager import DatabaseManager
import math

class PatrimonioController(QWidget):
    # ... (O código completo do patrimonio_controller.py fornecido na resposta anterior) ...
    # Devido ao limite de caracteres, use o código completo da resposta anterior.
    # O código é extenso, mas é o que garante todas as funcionalidades.
    
    # Se precisar do código novamente, solicite.
    pass

